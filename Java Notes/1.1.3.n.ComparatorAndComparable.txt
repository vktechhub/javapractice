Comparator and Comparable in Java:-

Comparable interface and compareTo() method: 
    This is used for defining the natural ordering of objects within a class. 
    A class implements the Comparable interface and overrides the compareTo(T o) method. 
    This method returns:
        A negative integer if the current object is less than the specified object.
        Zero if the current object is equal to the specified object.
        A positive integer if the current object is greater than the specified object.

Comparator interface and compare() method: 
    This is used for defining custom ordering of objects, allowing for multiple sorting criteria. 
    A Comparator is typically implemented in a separate class or as a lambda expression. 
    The compare(T o1, T o2) method takes two objects and returns 
        a negative integer if the first object is less than the second,
        zero if the first object is equal to the second,
        a positive integer if the first object is greater than the second.


Subinterfaces of Comparator:
    1. BiComparator: A functional interface that extends Comparator to compare two objects of different types.
    2. DoubleComparator: A specialized comparator for comparing double values.
    3. IntComparator: A specialized comparator for comparing int values.
    4. LongComparator: A specialized comparator for comparing long values.
    5. PrimitiveComparator: A general interface for comparing primitive types.
    6. ToDoubleComparator: A functional interface for comparing objects based on a double-valued function.
    7. ToIntComparator: A functional interface for comparing objects based on an int-valued function.
    8. ToLongComparator: A functional interface for comparing objects based on a long-valued function.

Subinterfaces of Comparable:
    1. Comparable<T>: The main interface for defining natural ordering.
    2. ComparableWithContext<T, C>: An interface that allows comparison with additional context information.
    3. ReverseComparable<T>: An interface that defines reverse natural ordering.
    4. SafeComparable<T>: An interface that provides safe comparison methods to avoid NullPointerExceptions.
    5. ContextualComparable<T, C>: An interface that allows comparison based on additional context.
These interfaces and their methods are essential for sorting and ordering objects in Java collections, such as lists and sets. They provide flexibility in defining how objects should be compared and ordered based on different criteria.

How to use Comparator interface:
public class Cars {
    String Model;
    int Year;
    public Cars(String model, int year) {
        Model = model;
        Year = year;
    }
}

public SortByYear implements Comparator {
    @Override
    public int compare(Cars c1, Cars c2) {
        // Make sure that the objects are Car objects
        Car a = (Car) obj1;
        Car b = (Car) obj2;
        
        // Compare the year of both objects
        if (a.year < b.year) return -1; // The first car has a smaller year
        if (a.year > b.year) return 1;  // The first car has a larger year
        return 0; // Both cars have the same year
    }
}

public class Main { 
  public static void main(String[] args) { 
    // Create a list of cars
    ArrayList<Car> myCars = new ArrayList<Car>();    
    myCars.addAll(new Car("Toyota", "Corolla", 2010), 
                   new Car("Honda", "Civic", 2015), 
                   new Car("Ford", "Focus", 2012));
    // Use a comparator to sort the cars
    Comparator myComparator = new SortByYear();
    Collections.sort(myCars, myComparator);
  } 
}

How to use Comparable interface:
public class Cars implements Comparable<Cars> {
    String Model;
    int Year;
    public Cars(String model, int year) {
        Model = model;
        Year = year;
    }

    @Override
    public int compareTo(Cars other) {
        // Compare the year of both cars
        if (this.Year < other.Year) return -1; // This car has a smaller year
        if (this.Year > other.Year) return 1;  // This car has a larger year
        return 0; // Both cars have the same year
    }
}

public class Main { 
  public static void main(String[] args) { 
    // Create a list of cars
    ArrayList<Car> myCars = new ArrayList<Car>();    
    myCars.addAll(new Car("Toyota", "Corolla", 2010), 
                   new Car("Honda", "Civic", 2015), 
                   new Car("Ford", "Focus", 2012));
    // Sort the cars using their natural ordering
    Collections.sort(myCars);
  } 
}
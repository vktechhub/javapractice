üß© Primitive Data Types
Type	Size	Range	                    Example
byte	8-bit	-128 to 127	                byte b = 10;
short	16-bit	-32,768 to 32,767	        short s = 1000;
int	    32-bit	~ -2 billion to +2 billion	int count = 25;
long	64-bit	Huge range	                long phone = 9876543210L;
float	32-bit	Decimal (approx.)	        float price = 10.5f;
double	64-bit	More precise decimal	    double pi = 3.14159;
char	16-bit Unicode char	'A', '9', etc.	char grade = 'A';
boolean	1-bit (true/false)	Logical values	boolean isReady = true;

üì¶ Reference Data Types
Reference types store the address (reference) of an object, not the actual value.
They are created using classes, interfaces, arrays, Collections or enums.

üß± 1. Class Type
Created from a class definition. Holds objects created from user-defined or built-in classes.

First Example:-
Student s1 = new Student();           // Custom class

Second Example:-
String name = "Vignesh";              // String is a class (special case, no need for new)

üî¢ 2. Wrapper Classes (for Primitives)

Used to wrap primitive types into objects.
(Commonly used with collections, generics, etc.) (e.g., List<Integer> instead of List<int>).

Primitive	Wrapper Class	Example
byte	    Byte	        Byte b = 10;
short	    Short	        Short s = 25;
int	        Integer	        Integer num = 50;
long	    Long	        Long phone = 9876543210L;
float	    Float	        Float rate = 45.6f;
double	    Double	        Double price = 99.99;
char	    Character	    Character grade = 'A';
boolean	    Boolean	        Boolean flag = true;

üßÆ 3. Arrays
A group of elements of the same data type of fixed array size.
Reference points to the memory block where array elements are stored.

int[] marks = {85, 90, 95};
String[] names = new String[5];

üß∞ 4. Collections Framework
Java provides powerful collection classes for storing groups of objects.
Used for dynamic, flexible data structures (unlike fixed-size arrays).

Category	Interface	Common Implementations	
List	    List<E>	    ArrayList, LinkedList	
Set	        Set<E>	    HashSet, LinkedHashSet, TreeSet	
Map	        Map<K, V>	HashMap, LinkedHashMap, TreeMap	
Queue	    Queue<E>	LinkedList, PriorityQueue, ArrayDeque

üß© 5. Interface Types
Reference variable can also refer to an object of a class that implements an interface.
Allows polymorphism (object behaves as per the interface it implements).\

Runnable task = new Thread();
List<Integer> list = new ArrayList<>();

üéöÔ∏è 6. Enum Types
Used for fixed sets of constants. 
Type-safe alternative to using constant integers or strings.

enum Day { MONDAY, TUESDAY, WEDNESDAY }
Day today = Day.MONDAY;

üåê 7. Null Reference
All reference types can hold a null value (means: ‚Äúno object‚Äù assigned).
String name = null;  // reference doesn‚Äôt point to any object

8. Record
A record is a special type of class introduced in Java 14 (preview) and made official in Java 16.
It is designed for classes that are just data carriers ‚Äî like simple DTOs (Data Transfer Objects) or POJOs with:
private fields
constructor
getters
equals(), hashCode(), and toString()
‚úÖ A record automatically provides all these ‚Äî you don‚Äôt have to write them yourself!

Example:
record Person(String name, int age) { }

For record Person(String name, int age) Java automatically creates:

// 1. Private final fields
private final String name;
private final int age;

// 2. Canonical constructor
public Person(String name, int age) {
    this.name = name;
    this.age = age;
}

// 3. Accessor methods (getters, but without 'get' prefix)
public String name() { return name; }
public int age() { return age; }

// 4. equals(), hashCode(), and toString() methods
// all auto-generated based on fields


So you can use:

Person p = new Person("Vignesh", 25);
System.out.println(p.name());     // Output: Vignesh
System.out.println(p.age());      // Output: 25
System.out.println(p);            // Output: Person[name=Vignesh, age=25]


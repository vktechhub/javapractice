JPA Annotations and important notes:-

All JPA annotations are part of the javax.persistence package.
Hibernate also supports all JPA annotations along with its own specific annotations. 
Most of the Hibernate-specific annotations are in the org.hibernate.annotations package, which are getting depreceated in favor of JPA standard annotations.

@Entity: This annotation is used to specify that the class is an entity and is mapped to a database table.
    * the name of the class corresponds to the table name by default, but it can be overridden using the @Table annotation.
    * In JPA when an entity class is defined using the @Entity annotation, it must have a no-argument constructor. This constructor can be public or protected. the reason is that JPA uses reflection to create instances of the entity class when retrieving data from the database. If there is no no-argument constructor, JPA will not be able to instantiate the entity, leading to runtime errors.

persistence.xml file:- The persistence.xml file contains the configuration details for JPA, including the database connection settings, the JPA provider (e.g., Hibernate), and other properties related to entity management.
    * It is typically located in the src/main/resources/META-INF directory of the classpath.

persistence unit:- A persistence unit is a logical grouping of user defined classes whose objects will be persisted in the database and their associated configuration settings. 
It is defined in the persistence.xml file using the <persistence-unit> element.
    * The name attribute of the <persistence-unit> element specifies the name of the persistence unit, which is used to create an EntityManagerFactory.
    * The persistence unit contains bunch of properties like the JPA provider, database connection details, and other configuration settings.

We need a way to tell JPA whether the table has to be created automatically or not. 
This is done using the "hibernate.hbm2ddl.auto" property in the persistence.xml file or in the application.properties file (if using Spring Boot) or javax.persistence.schema-generation.database.action property value="create". 
The possible values for this property are:
    * create: This option will drop the existing schema and create a new schema every time the application is started.
    * update: This option will update the existing schema without dropping it. It will add new tables or columns as needed but will not remove any existing tables or columns.
    * validate: This option will validate the existing schema against the entity mappings. If there are any discrepancies, an exception will be thrown.
    * none: This option will not perform any schema generation or validation.

@Table(name=xyz): This annotation is used to specify the name of the database table to which the entity is mapped.

@Id: This annotation is used to specify the primary key of an entity.
    * if @Id is not specified, the JPA provider will throw an exception.
    * primary key can be a single field or a combination of multiple fields (composite key) using @IdClass or @EmbeddedId.
    * primary key fields should be unique and not null.
    * @Id can be applied to fields and getter methods.
    * if @Id is applied to a field, even if that table is not having primary key constraint, JPA will treat that field as primary key.

Whenever fields of Primitive data types are used in Entity classes, it is recommended to use their Wrapper classes instead.
    * This is because primitive data types have default values (e.g., 0 for int, false for boolean), which can lead to unintended behavior when persisting entities.
    * and they are non -nullable by default, which can cause issues when dealing with null values in the database.

Fields whose data types are Java classes can hold null values, so they are preferred in Entity classes.

@GeneratedValue: This annotation is used to specify the generation strategy for the primary key values.
    * It can be used in conjunction with the @Id annotation.
    * The strategy attribute specifies the generation strategy to be used.
    * The possible strategies are:
        - AUTO(default): The JPA provider will choose the appropriate strategy based on the database dialect.
        - IDENTITY: The primary key values will be generated by the database using an auto-increment column.
        - SEQUENCE: The primary key values will be generated using a common database sequence. default allocation size is 50.
         Note: In Hibernate, when using the SEQUENCE strategy with @GeneratedValue, the default allocation size is 50. This means that Hibernate will fetch primary key values in increments of 50 from the database sequence to optimize performance.
         To change the default allocation size, you can use the @SequenceGenerator annotation to specify a custom allocation size.
        - TABLE: The primary key values will be generated using a table to store the last generated value.
                * @TableGenerator annotation is used to specify the details of the table used for primary key generation.
                * table="name of the table", pkColumnName="name of the primary key column", pkColumnValue="primary key column value", valueColumnName="name of the column that stores the last generated value", allocationSize=number of values to be allocated at a time.

Composite keys:-   * Composite keys are used when an entity has a primary key that consists of multiple fields.
    * There are two ways to define composite keys in JPA:
        - Using @IdClass: This approach involves creating a separate class that represents the composite key and annotating it with @IdClass. 
        The entity class then uses multiple @Id annotations to specify the fields that make up the composite key.
        - Using @EmbeddedId: This approach involves creating an embeddable class that represents the composite key and annotating it with @Embeddable. 
        The entity class then uses a single @EmbeddedId annotation to specify the composite key.
        @EmbeddedId is combination of @Embeddable and @Id.

@Embeddable: This annotation is used to specify that a class is embeddable and can be embedded in an entity.
@Embedded: This annotation is used to specify that a field or property is an embedded object.   

@Column: This annotation is used to specify the details of the column to which a field or property is mapped.
    * @Column(name="column_name"): Specifies the name of the column in the database table.
    * nullable=true/false: Specifies whether the column can contain null values.
    * unique=true/false: Specifies whether the column should have a unique constraint.
    * columnDefinition="data_type": Specifies the SQL data type of the column.
    * precision=number: Specifies the precision for decimal columns.
    * scale=number: Specifies the scale for decimal columns.
    
@Transient: This annotation is used to specify that a field or property is not persistent and should not be mapped to a database column.

Date and Time Mapping:-
    * In JPA, the java.util.Date and java.util.Calendar types can be mapped to different SQL types using the @Temporal annotation.
    * The @Temporal annotation is used to specify the temporal type of a date or calendar field.
    * The possible temporal types are:
        - @Temporal(TemporalType.DATE): Maps to SQL DATE type (only date, no time).
        - @Temporal(TemporalType.TIME): Maps to SQL TIME type (only time, no date).
        - @Temporal(TemporalType.TIMESTAMP): Maps to SQL TIMESTAMP type (date and time).

Large Objects:-
    * In JPA, large objects such as BLOBs (Binary Large Objects) and CLOBs (Character Large Objects) can be mapped using the @Lob annotation.
    * The @Lob annotation can be applied to fields or properties of type byte[], Byte[], String, java.sql.Clob, java.sql.Blob, etc.
    * When a field or property is annotated with @Lob, the JPA provider will handle the storage and retrieval of large objects appropriately.


@OneToOne: This annotation is used to specify a one-to-one relationship between two entities.
@OneToMany: This annotation is used to specify a one-to-many relationship between two entities.
@ManyToOne: This annotation is used to specify a many-to-one relationship between two entities.
@ManyToMany: This annotation is used to specify a many-to-many relationship between two entities.
@JoinColumn: This annotation is used to specify the foreign key column for a relationship.
@JoinTable: This annotation is used to specify the join table for a many-to-many relationship.
@Inheritance: This annotation is used to specify the inheritance strategy for entity classes.
@DiscriminatorColumn: This annotation is used to specify the discriminator column for single table inheritance.
@DiscriminatorValue: This annotation is used to specify the discriminator value for a subclass in single table inheritance.
@Version: This annotation is used to specify the version field for optimistic locking.
@Lob: This annotation is used to specify that a field or property should be treated as a large object (LOB) in the database.
@NamedQuery: This annotation is used to define a static named query at the entity level.    
@NamedQueries: This annotation is used to define multiple static named queries at the entity level.
@SqlResultSetMapping: This annotation is used to define the mapping of the result set of a native SQL query to entities or scalar values.
@Converter: This annotation is used to define a custom converter for mapping between the database and the entity attribute.
@Convert: This annotation is used to specify the use of a custom converter for a specific entity attribute.
@AttributeOverride: This annotation is used to override the mapping of an embedded attribute.
@AttributeOverrides: This annotation is used to override the mappings of multiple embedded attributes.
@Access: This annotation is used to specify the access type (field or property) for an entity or a specific attribute.
@Cacheable: This annotation is used to specify whether the entity should be cached by the second-level cache.
@OrderBy: This annotation is used to specify the ordering of a collection of entities.
@OrderColumn: This annotation is used to specify a column that maintains the order of a list of entities.
@ElementCollection: This annotation is used to specify a collection of basic or embeddable types.
@CollectionTable: This annotation is used to specify the table that stores the collection of embeddable types or basic types.
@MapKey: This annotation is used to specify the map key for a map collection.
@MapKeyColumn: This annotation is used to specify the column that stores the map key for a map collection.
@MapKeyJoinColumn: This annotation is used to specify the join column that stores the map key for a map collection of entities.
@OrderColumn: This annotation is used to specify a column that maintains the order of a list of entities.
@Fetch: This annotation is used to specify the fetch strategy (eager or lazy) for a relationship or collection.
@BatchSize: This annotation is used to specify the batch size for fetching collections or entities.
@FetchProfile: This annotation is used to define a fetch profile for optimizing entity loading.
@NamedEntityGraph: This annotation is used to define a named entity graph for specifying fetch plans
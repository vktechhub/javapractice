âœ… 1. What Are Generics?
Generics enable types (classes and interfaces) to be parameters when defining classes, interfaces, and methods. This allows for code reusability and type safety.
Example:
List<String> list = new ArrayList<>();
here String is the type parameter for the generic class List.

âœ… 2. Key Concepts of Generics

âœ… Generics are type parameters, not data types themselves.
Generics are not a separate data type category, as they are a feature of reference types (specifically, of classes, interfaces, and methods) that work with different data types safely (type-safe, compile-time checking).

Why Do We Use Generics?
* Generics allow you to write type-safe, reusable code.
* They add type parameters (like <T>, <E>, <K, V>) to classes, interfaces, and methods.
* Generics catch type errors at compile time â†’ safer code
* Eliminate the need for casting
* Reusable algorithms
* Better readability

ğŸ§± Generics Can Be Used In
Where	                Example	                            Explanation
Generic Class	        class Box<T> { T value; }	        T is a type parameter
Generic Interface	    interface Comparable<T>	            Used in sorting, etc.
Generic Method	<T>     void print(T item)	                Works for any type
Generic Collection	    List<String>, Map<Integer, String>	Part of Java Collections Framework

âœ… 3. Generic Type Parameters
Common naming conventions:

Symbol	Meaning
T	    Type
E	    Element
K	    Key
V	    Value
N	    Number
?	    Wildcard

Example:
class Box<T> {
    private T value;
    public void set(T value) { this.value = value; }
    public T get() { return value; }
}

Usage:
Box<Integer> box = new Box<>();
box.set(100);
System.out.println(box.get());

âœ… 4. Generic Methods
A method can define its own type parameter.

public <T> void print(T value) {
    System.out.println(value);
}

Calling it:
print("Hello");
print(100);
print(10.5);

âœ… 5. Bounded Generics - Restricts type to subclass of a given class
Upper Bound (extends):

public <T extends Number> void show(T value) {
    System.out.println(value.doubleValue());
}

    Valid:
        Integer
        Double
        Long
    Invalid:
        String

Lower Bound (super) - Used mainly in collections.

public void addNumbers(List<? super Integer> list) {
    list.add(10);
    list.add(20);
}

    Accepts:
        List<Integer>
        List<Number>
        List<Object>

âœ… 6. Wildcards (?)
Unbounded Wildcard
    List<?> list
        Readable but NOT addable(except null) because type is unknown.
    
Upper Bounded Wildcard
    List<? extends Number>
        Readable but NOT addable (except null).

Lower Bounded Wildcard
    List<? super Integer>

Writable.

ğŸ“Œ Summary
Type	            Read	Write
List<?>	            âœ”	    âœ–
List<? extends T>	âœ”	    âœ–
List<? super T>	    âœ”	    âœ”(T or child)

âœ… 7. PECS Rule 
        Producer Extends, Consumer Super
            Use ? extends T when you read/consume from the list
            Use ? super T when you write/add to the list

            Example:

List<? extends Number> producer = new ArrayList<Integer>();
Number n = producer.get(0); // OK
producer.add(10);           // ERROR

List<? super Integer> consumer = new ArrayList<Number>();
consumer.add(10); // OK
Integer x = consumer.get(0); // Needs cast

âœ… 8. Generic Interfaces
        interface Mapper<T> {
            T process(T input);
        }

        class StringMapper implements Mapper<String> {
            public String process(String input) {
                return input.toUpperCase();
            }
        }

âœ… 9. Bounded Type Parameters with Multiple Bounds
        <T extends Number & Comparable<T>> void maxValue(T a, T b) {
            System.out.println(a.compareTo(b) > 0 ? a : b);
        }


        âœ” Class must come first
        âœ” Interfaces can follow

âœ… 10. Generic Constructors
            class Test {
                <T> Test(T value) {
                    System.out.println(value);
                }
            }

âœ… 11. Type Erasure (Runtime Behavior)
            âœ” Generics exist only at compile time
            âœ” JVM sees raw types

            Example:

            List<String> l1 = new ArrayList<>();
            List<Integer> l2 = new ArrayList<>();
            System.out.println(l1.getClass() == l2.getClass()); // true

            Because both become:
            List

âœ… 12. Restrictions with Generics

        âŒ No primitive types
        List<int> â†’ not allowed
        Use List<Integer>

        âŒ Cannot instantiate generic type
        T obj = new T(); â†’ error

        âŒ No static fields with generic type
        static T value; â†’ not allowed

        âŒ No instanceof with parameterized types
        obj instanceof List<String> â†’ not allowed

        âŒ Cannot create arrays of parameterized types
        List<String>[] arr = new List<String>[10]; â†’ not allowed
        
âœ… 13. Write a method to find the maximum element in a list of Numbers:

        public static <T extends Comparable<T>> T max(List<T> list) {
            T max = list.get(0);
            for (T item : list) {
                if (item.compareTo(max) > 0) {
                    max = item;
                }
            }
            return max;
        }

        Usage:
        List<Integer> nums = List.of(1, 3, 2, 10);
        System.out.println(max(nums)); // 10

âœ… 14. Summary of Generics in Java
        âœ” Generics provide type safety and reusability
        âœ” They allow parameterization of types
        âœ” Support for generic classes, interfaces, and methods
        âœ” Bounded type parameters restrict types
        âœ” Wildcards provide flexibility in method parameters




âœ” How generics are implemented internally (type erasure)
        âœ” Generics exist only at compile time
        âœ” JVM sees raw types
        



âœ” Generics best practices
        âœ” Use meaningful type parameter names
        âœ” Follow PECS rule for collections
        âœ” Avoid raw types
        âœ” Use bounded type parameters when necessary
        âœ” Understand limitations and restrictions of generics
        âœ” How generics are implemented internally (type erasure)
        
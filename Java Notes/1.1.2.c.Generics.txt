Why Do We Use Generics?
* Generics allow you to write type-safe, reusable code.
* They add type parameters (like <T>, <E>, <K, V>) to classes, interfaces, and methods.
* Generics catch type errors at compile time â†’ safer code
* Eliminate the need for casting
* Reusable algorithms
* Better readability
âœ… Generics are type parameters, not data types themselves.
Generics are not a separate data type category, as they are a feature of reference types (specifically, of classes, interfaces, and methods) that work with different data types safely (type-safe, compile-time checking).



ğŸ§± Generics Can Be Used In
Where	            Example	                            Explanation
Generic Class	    class Box<T> { T value; }	        T is a type parameter
Generic Interface	interface Comparable<T>	            Used in sorting, etc.
Generic Method	<T> void print(T item)	                Works for any type
Generic Collection	List<String>, Map<Integer, String>	Part of Java Collections Framework



âœ… 3. Generic Type Parameters

Common naming conventions:

Symbol	Meaning
T	Type
E	Element
K	Key
V	Value
N	Number
?	Wildcard

Example:

class Box<T> {
    private T value;
    public void set(T value) { this.value = value; }
    public T get() { return value; }
}


Usage:

Box<Integer> box = new Box<>();
box.set(100);
System.out.println(box.get());

âœ… 4. Generic Methods

A method can define its own type parameter.

public <T> void print(T value) {
    System.out.println(value);
}


Calling it:

print("Hello");
print(100);
print(10.5);

âœ… 5. Bounded Generics
Upper Bound (extends)

Restricts type to subclass of a given class.

public <T extends Number> void show(T value) {
    System.out.println(value.doubleValue());
}


Valid:

Integer

Double

Long

Invalid:

String

Lower Bound (super)

Used mainly in collections.

public void addNumbers(List<? super Integer> list) {
    list.add(10);
    list.add(20);
}


Accepts:

List<Integer>

List<Number>

List<Object>

âœ… 6. Wildcards (?)
Unbounded Wildcard
List<?> list


You can't add elements (except null) because type is unknown.

Upper Bounded Wildcard
List<? extends Number>


Readable but NOT addable (except null).

Lower Bounded Wildcard
List<? super Integer>


Writable.

ğŸ“Œ Summary
Type	Read	Write
List<?>	âœ”	âœ–
List<? extends T>	âœ”	âœ–
List<? super T>	âœ”	âœ”(T or child)
âœ… 7. PECS Rule (VERY important for interviews)

Producer Extends, Consumer Super

Use ? extends T when you read/consume from the list

Use ? super T when you write/add to the list

Example:

List<? extends Number> producer = new ArrayList<Integer>();
Number n = producer.get(0); // OK
producer.add(10);           // ERROR

List<? super Integer> consumer = new ArrayList<Number>();
consumer.add(10); // OK
Integer x = consumer.get(0); // Needs cast

âœ… 8. Generic Interfaces
interface Mapper<T> {
    T process(T input);
}

class StringMapper implements Mapper<String> {
    public String process(String input) {
        return input.toUpperCase();
    }
}

âœ… 9. Bounded Type Parameters with Multiple Bounds
<T extends Number & Comparable<T>> void maxValue(T a, T b) {
    System.out.println(a.compareTo(b) > 0 ? a : b);
}


âœ” Class must come first
âœ” Interfaces can follow

âœ… 10. Generic Constructors
class Test {
    <T> Test(T value) {
        System.out.println(value);
    }
}

âœ… 11. Type Erasure (Runtime Behavior)

Important interview concept.

âœ” Generics exist only at compile time
âœ” JVM sees raw types

Example:

List<String> l1 = new ArrayList<>();
List<Integer> l2 = new ArrayList<>();
System.out.println(l1.getClass() == l2.getClass()); // true


Because both become:

List

âœ… 12. Restrictions with Generics

âŒ No primitive types
List<int> â†’ not allowed
Use List<Integer>

âŒ Cannot instantiate generic type
T obj = new T(); â†’ error

âŒ No static fields with generic type
static T value; â†’ not allowed

âŒ No instanceof with parameterized types
obj instanceof List<String> â†’ not allowed

âœ… 13. Putting It All Together (Interview Problem)
Write a method to find the maximum element in a list of Numbers:
public static <T extends Comparable<T>> T max(List<T> list) {
    T max = list.get(0);
    for (T item : list) {
        if (item.compareTo(max) > 0) {
            max = item;
        }
    }
    return max;
}


Usage:

List<Integer> nums = List.of(1, 3, 2, 10);
System.out.println(max(nums)); // 10

ğŸ¯ Want more?

I can teach you:

âœ” Generics best practices
âœ” Real-time code examples
âœ” Generics interview questions & answers
âœ” Complex wildcard scenarios
âœ” Generics in Java Collections
âœ” How generics are implemented internally (type erasure)

Just tell me which direction you want to go next.
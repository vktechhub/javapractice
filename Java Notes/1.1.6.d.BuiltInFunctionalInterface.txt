Here’s a practical cheat-sheet for when to choose which Java functional interface—especially when you plan to use method references.

1. **Supplier<T>**
   - Use when you need to generate or supply values without any input.
   - Method Reference Example: `ClassName::staticMethod` or `instance::instanceMethod` that returns a value.
   - Example: `Supplier<Double> randomValue = Math::random;`

2. **Consumer<T>**
   - Use when you need to perform an action on a single input without returning a result.
   - Method Reference Example: `ClassName::staticMethod` or `instance::instanceMethod` that takes one argument and returns void.
   - Example: `Consumer<String> print = System.out::println;`

3. **Function<T, R>**
   - Use when you need to transform an input of type T to an output of type R.
   - Method Reference Example: `ClassName::staticMethod` or `instance::instanceMethod` that takes one argument and returns a value.
   - Example: `Function<String, Integer> stringToLength = String::length;`

4. **Predicate<T>**


   Pick the interface by: inputs ▸ output ▸ purpose
🧭 Java Functional Interface Reference (for Lambdas & Method References)
Inputs	Interface	        Output	Need / Purpose / Use it when…
T	    Consumer<T>	        void	Perform an action	               You want to “use” a value (e.g., print, log, save) without returning anything
T, U	BiConsumer<T,U>	    void	Perform an action using two inputs	You want to handle two values together (e.g., key–value pairs)
T	    Function<T,R>	    R	    Transform input to output	       You need to map or convert a value from one type to another
T, U	BiFunction<T,U,R>	R	    Combine two inputs into one output	You want to produce a result from two inputs
T	    UnaryOperator<T>	T	    Modify and return same type	       You want to apply a change and get the same type back (e.g., trim, uppercase)
T, T	BinaryOperator<T>	T	    Combine two of the same type	You want to reduce or aggregate values of the same type (e.g., sum, concat)
T	    Predicate<T>	    boolean	Test a condition	You want to check or filter based on a condition
T, U	BiPredicate<T,U>	boolean	Test a condition on two inputs	You want to compare or match two inputs (e.g., equals, startsWith)
—	    Supplier<T>	        T	    Supply or generate a value	You want to create or provide something without input (factory/lazy creation)
—	    Runnable	        void	Run a task (no return)	You want to execute a task with no input or output
—	    Callable<V>	        V	    Run a task that returns a value	You want to execute a task that returns a result and may throw exceptions
T, T	Comparator<T>	    int	    Compare two values	You want to define sorting or ordering logic

⚠️ “Calculator” isn’t a standard JDK functional interface. You likely meant Callable (task that returns a value) or the Operator types (Unary/Binary) used for “calculations”. If you do have a custom Calculator, prefer using the closest standard interface above unless you truly need custom semantics.


🧠 Quick Recall + Practical Summary
🎯 Choose the Right Functional Interface
Intent / Action	                Best Interface(s)	                                   Key Idea
✅ Use / Perform an action	   Consumer<T>, BiConsumer<T,U>, Runnable	               You “do something” (side effect) without returning a value
🏭 Create / Supply	            Supplier<T>	                                            You “create” or “provide” something — no inputs, just return a new or existing value
🔄 Transform / Map	            Function<T,R>, BiFunction<T,U,R>	                    You “transform” input(s) into output(s) (different types allowed)
⚙️ Calculate / Combine	        UnaryOperator<T>, BinaryOperator<T>, BiFunction<T,U,R>	You “process” or “combine” values — usually same type in/out
🔍 Check / Test condition	    Predicate<T>, BiPredicate<T,U>	                        You “check” or “filter” something — returns boolean
🚀 Run / Execute a task	        Runnable, Callable<V>	                                You “run” a task — may or may not return a result
🔢 Sort / Compare	            Comparator<T>	                                        You “compare” two values for ordering


🧩 General Selection Rules

    Need a result? → Use Supplier, Function, BiFunction, UnaryOperator, BinaryOperator, or Callable.
    Need same type in/out? → Use UnaryOperator<T> (1 input) or BinaryOperator<T> (2 inputs).
    Need two inputs of any type and one output? → Use BiFunction<T,U,R>.
    No result, just side effect? → Use Consumer, BiConsumer, or Runnable.
    Just a boolean answer? → Use Predicate or BiPredicate.
    Sorting or ordering? → Use Comparator.

💡 Pro Tips

    Prefer the most specific interface
        → e.g., UnaryOperator<T> over Function<T,T> improves clarity and overload resolution.

    Use primitive specializations for performance-critical code (avoid boxing/unboxing):

    IntFunction<R>, IntUnaryOperator, IntBinaryOperator, IntPredicate, IntConsumer, etc.

    Also available for Long* and Double*.

    Method Reference Mapping:

    Static method → ClassName::staticMethod → works with Function, BiFunction, etc.

    Instance method (on object) → object::method → works with Consumer, Runnable.

    Instance method (on type) → ClassName::instanceMethod → first param is receiver.

    Constructor → ClassName::new → maps to Supplier or Function.

🧭 TL;DR – Think Like This
    Question	                      Use
    “I just need to do something.”	→ Consumer
    “I need to make something.”	    → Supplier
    “I need to change something.”	→ Function
    “I need to check something.”	→ Predicate
    “I need to calculate/combine something.”	→ Operator / BiFunction
    “I need to run a task.”	        → Runnable / Callable